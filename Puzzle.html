<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Block Puzzle JavaScript</title>
    <style>
        :root {
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --accent-color: #FF6B6B;
            --text-color: white;
            --board-bg: rgba(0, 0, 0, 0.4);
        }
        
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body {
            margin: 0;
            padding: 2vmin;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            font-family: 'Arial', sans-serif;
            overflow-x: hidden;
            touch-action: manipulation;
        }
        
        #gameContainer {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 3vmin;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 1600px;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 3vmin;
        }
        
        #gameHeader {
            display: flex;
            flex-direction: column;
            gap: 2vmin;
            align-items: center;
        }
        
        .game-title {
            color: #FFD700;
            font-size: clamp(24px, 6vmin, 48px);
            margin: 0;
            text-shadow: 3px 3px 0 #000;
            font-weight: bold;
            order: 1;
        }
        
        #gameInfo {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 2vmin;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            padding: 2vmin;
            border-radius: 10px;
            font-size: clamp(14px, 3vmin, 20px);
            font-weight: bold;
            order: 2;
            width: 100%;
            max-width: 600px;
        }
        
        #gameInfo > div {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .info-value {
            font-size: clamp(16px, 4vmin, 24px);
            color: #FFD700;
            margin-top: 0.5vmin;
        }
        
        .music-control {
            position: absolute;
            top: 2vmin;
            right: 2vmin;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 1.5vmin;
            border-radius: 50%;
            cursor: pointer;
            font-size: clamp(18px, 4vmin, 24px);
            width: clamp(45px, 9vmin, 60px);
            height: clamp(45px, 9vmin, 60px);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .music-control:hover, .music-control:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        #gameContent {
            display: flex;
            flex-direction: column;
            gap: 3vmin;
        }
        
        /* LAYOUT PARA ESCRITORIO - Tablero grande a la izquierda, piezas a la derecha */
        @media (min-width: 1024px) {
            #gameContent {
                flex-direction: row;
                align-items: flex-start;
                gap: 4vmin;
            }
            
            #mainGameArea {
                flex: 3;
                display: flex;
                flex-direction: column;
                gap: 3vmin;
            }
            
            #sidePanels {
                flex: 2;
                display: flex;
                flex-direction: column;
                gap: 3vmin;
                min-width: 400px;
            }
            
            #mainBoard {
                max-width: 700px !important;
                align-self: center;
            }
            
            #currentPiecesArea {
                order: 1;
                height: auto;
            }
            
            #nextPiecesArea {
                order: 2;
            }
            
            #nextPiecesBoard {
                max-width: 100% !important;
                height: 120px !important;
            }
        }
        
        /* LAYOUT PARA TABLETS */
        @media (min-width: 768px) and (max-width: 1023px) {
            #gameContent {
                flex-direction: column;
            }
            
            #mainBoard {
                max-width: 500px !important;
            }
            
            #sidePanels {
                display: flex;
                flex-direction: row;
                gap: 3vmin;
            }
            
            #currentPiecesArea {
                flex: 2;
            }
            
            #nextPiecesArea {
                flex: 1;
            }
            
            #nextPiecesBoard {
                height: 200px !important;
            }
        }
        
        /* √ÅREA DE PIEZAS ACTUALES */
        #currentPiecesArea {
            order: 1;
            padding: 3vmin;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            width: 100%;
        }
        
        .current-pieces-title {
            color: white;
            font-size: clamp(16px, 3.5vmin, 22px);
            margin-bottom: 2vmin;
            font-weight: bold;
        }

        #currentPiecesBoard {
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: var(--board-bg);
            margin: 0 auto;
            cursor: grab;
            width: 100%;
            max-width: 800px;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .touch-hint {
            color: #FFD700;
            font-size: clamp(12px, 2.5vmin, 16px);
            margin: 1vmin 0 2vmin 0;
            font-style: italic;
        }
        
        /* BOTONES DE ROTACI√ìN - MEJORADOS */
        .rotate-buttons {
            display: flex;
            justify-content: center;
            gap: 1vmin;
            margin-top: 2vmin;
            flex-wrap: wrap;
        }

        .rotate-btn {
            background: #4ECDC4;
            color: white;
            border: none;
            padding: 1vmin 2vmin;
            border-radius: 15px;
            cursor: pointer;
            font-size: clamp(11px, 2.2vmin, 14px);
            min-width: 80px;
            min-height: 35px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
            flex: 1;
            max-width: 100px;
        }

        .rotate-btn:hover, .rotate-btn:active {
            background: #3db8af;
            transform: scale(1.05);
        }
        
        /* √ÅREA DEL TABLERO PRINCIPAL */
        #mainGameArea {
            order: 2;
        }
        
        .board {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 2.5vmin;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .board-title {
            color: white;
            margin-bottom: 2vmin;
            font-size: clamp(16px, 3.5vmin, 22px);
            font-weight: bold;
            text-align: center;
        }
        
        #mainBoard {
            border: 3px solid rgba(255, 255, 255, 0.3);
            background: var(--board-bg);
            cursor: pointer;
            width: 100%;
            max-width: 500px;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        /* √ÅREA DE PR√ìXIMAS PIEZAS - HORIZONTAL EN M√ìVIL */
        #nextPiecesArea {
            order: 3;
            padding: 2vmin;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            width: 100%;
        }
        
        #nextPiecesBoard {
            border: 3px solid rgba(255, 255, 255, 0.3);
            background: var(--board-bg);
            width: 100%;
            max-width: 300px;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            margin: 0 auto;
        }
        
        /* CONTROLES */
        #controls {
            order: 4;
            margin: 2vmin 0;
            display: flex;
            justify-content: center;
            gap: 2vmin;
            flex-wrap: wrap;
        }
        
        button {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 2vmin 4vmin;
            font-size: clamp(14px, 3vmin, 18px);
            cursor: pointer;
            border-radius: 25px;
            font-weight: bold;
            transition: all 0.3s;
            min-width: 140px;
            min-height: 50px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        button:hover, button:active {
            background: #FF5252;
            transform: scale(1.05);
        }
        
        .instructions {
            order: 5;
            background: rgba(255, 255, 255, 0.1);
            padding: 3vmin;
            border-radius: 10px;
            max-width: 800px;
            font-size: clamp(12px, 2.5vmin, 16px);
            line-height: 1.5;
            margin: 0 auto;
        }
        
        #messageDisplay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 215, 0, 0.95);
            color: #000;
            padding: 4vmin 6vmin;
            border-radius: 15px;
            font-size: clamp(20px, 5vmin, 32px);
            font-weight: bold;
            z-index: 100;
            display: none;
            animation: popIn 0.5s ease-out;
            text-align: center;
            max-width: 90vw;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            border: 3px solid #FFA500;
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            70% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        /* PANTALLAS DE INICIO Y FIN */
        #startScreen, #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: clamp(16px, 4vmin, 24px);
            z-index: 1000;
            padding: 5vmin;
            text-align: center;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* MEJORAS ESPEC√çFICAS PARA M√ìVILES */
        @media (max-width: 767px) {
            body {
                padding: 1vmin;
            }
            
            #gameContainer {
                padding: 2vmin;
                gap: 2vmin;
            }
            
            #gameInfo {
                grid-template-columns: repeat(2, 1fr);
                gap: 3vmin;
                max-width: 100%;
            }
            
            #currentPiecesBoard {
                height: 120px;
                max-width: 100%;
            }
            
            #nextPiecesBoard {
                height: 80px;
                max-width: 100%;
            }
            
            .rotate-buttons {
                gap: 0.5vmin;
                margin-top: 1vmin;
            }
            
            .rotate-btn {
                min-width: 70px;
                min-height: 30px;
                max-width: 80px;
                font-size: 10px;
                padding: 0.8vmin 1.5vmin;
            }
            
            #mainBoard {
                max-width: 95vw;
            }
            
            button {
                min-width: 120px;
                min-height: 45px;
                padding: 1.5vmin 3vmin;
            }
        }
        
        /* ESTADOS T√ÅCTILES MEJORADOS */
        @media (hover: none) and (pointer: coarse) {
            button, .rotate-btn {
                min-height: 44px;
            }
            
            #mainBoard, #currentPiecesBoard {
                cursor: default;
            }
        }
        
        .dragging {
            opacity: 0.8;
            transform: scale(1.05);
            transition: all 0.2s;
            cursor: grabbing !important;
        }

        .placement-preview {
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <button class="music-control" onclick="toggleMusic()">üéµ</button>
        
        <div id="gameHeader">
            <h1 class="game-title">üß© BLOCK PUZZLE üß©</h1>
            <div id="gameInfo">
                <div>PUNTOS<br><span id="score" class="info-value">0</span></div>
                <div>L√çNEAS<br><span id="lines" class="info-value">0</span></div>
                <div>NIVEL<br><span id="level" class="info-value">1</span></div>
                <div>BLOQUES<br><span id="blocksPlaced" class="info-value">0</span></div>
            </div>
        </div>

        <div id="messageDisplay"></div>
        
        <div id="gameContent">
            <!-- EN ESCRITORIO: Tablero grande a la izquierda -->
            <div id="mainGameArea">
                <div class="board">
                    <div class="board-title">TABLERO PRINCIPAL</div>
                    <canvas id="mainBoard"></canvas>
                </div>
            </div>
            
            <!-- EN ESCRITORIO: Paneles laterales a la derecha -->
            <div id="sidePanels">
                <!-- Piezas actuales con botones arriba -->
                <div id="currentPiecesArea">
                    <div class="board-title">PR√ìXIMAS PIEZAS</div>
                    <canvas id="nextPiecesBoard"></canvas>
                    <div class="current-pieces-title">PIEZAS ACTUALES</div>
                    <div class="touch-hint">Toca y arrastra al tablero</div>
                    
                    <!-- Botones de rotaci√≥n arriba de las piezas -->
                    <div class="rotate-buttons">
                        <button class="rotate-btn" onclick="rotatePiece(0)">‚Üª 1</button>
                        <button class="rotate-btn" onclick="rotatePiece(1)">‚Üª 2</button>
                        <button class="rotate-btn" onclick="rotatePiece(2)">‚Üª 3</button>
                    </div>
                    
                    <canvas id="currentPiecesBoard"></canvas>
                </div>
            </div>
        </div>
        
        <div id="controls">
            <button onclick="resetGame()">REINICIAR JUEGO</button>
        </div>
        
        <div class="instructions">
            <p>üí° <strong>INSTRUCCIONES:</strong></p>
            <p>‚Ä¢ Toca una pieza y arr√°strala al tablero principal</p>
            <p>‚Ä¢ Usa los botones para rotar cada pieza antes de colocarla</p>
            <p>‚Ä¢ Completa l√≠neas horizontales o verticales para ganar puntos</p>
            <p>‚Ä¢ ¬°Pierdes cuando no hay espacio para NINGUNA pieza!</p>
        </div>
    </div>

    <div id="startScreen">
        <h1 class="game-title">üß© BLOCK PUZZLE üß©</h1>
        <div class="instructions">
            <p>üéÆ <strong>¬øC√ìMO JUGAR?</strong></p>
            <p>‚Ä¢ Tienes 3 piezas para colocar en cada turno</p>
            <p>‚Ä¢ Arr√°stralas al tablero principal</p>
            <p>‚Ä¢ Rota las piezas para que encajen mejor</p>
            <p>‚Ä¢ Completa l√≠neas para ganar puntos y subir de nivel</p>
            <p>‚Ä¢ ¬°El juego termina cuando no puedes colocar NINGUNA pieza!</p>
        </div>
        <button onclick="startGame()">¬°COMENZAR JUEGO!</button>
    </div>

    <div id="gameOverScreen" class="hidden">
        <h1 class="game-title">üíÄ GAME OVER</h1>
        <p>Puntuaci√≥n final: <span id="finalScore" class="info-value">0</span></p>
        <p>L√≠neas completadas: <span id="finalLines" class="info-value">0</span></p>
        <button onclick="restartGame()">JUGAR DE NUEVO</button>
    </div>

    <!-- Audio elements -->
    <audio id="backgroundMusic" loop preload="auto">
        <source src="https://assets.mixkit.co/music/preview/mixkit-game-show-suspense-waiting-667.mp3" type="audio/mpeg">
    </audio>
    <audio id="lineCompleteSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" type="audio/mpeg">
    </audio>
    <audio id="piecePlaceSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-select-click-1109.mp3" type="audio/mpeg">
    </audio>
    <audio id="gameOverSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-sad-game-over-trombone-471.mp3" type="audio/mpeg">
    </audio>
    <audio id="rotateSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-cool-interface-click-tone-2568.mp3" type="audio/mpeg">
    </audio>

    <script>
        class BlockPuzzleGame {
            constructor() {
                this.mainCanvas = document.getElementById('mainBoard');
                this.mainCtx = this.mainCanvas.getContext('2d');
                this.nextCanvas = document.getElementById('nextPiecesBoard');
                this.nextCtx = this.nextCanvas.getContext('2d');
                this.currentCanvas = document.getElementById('currentPiecesBoard');
                this.currentCtx = this.currentCanvas.getContext('2d');
                
                this.gameState = 'menu';
                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.blocksPlaced = 0;
                
                this.boardSize = 10;
                this.cellSize = 0;
                
                // Elementos de audio
                this.backgroundMusic = document.getElementById('backgroundMusic');
                this.lineCompleteSound = document.getElementById('lineCompleteSound');
                this.piecePlaceSound = document.getElementById('piecePlaceSound');
                this.gameOverSound = document.getElementById('gameOverSound');
                this.rotateSound = document.getElementById('rotateSound');
                
                // Control de m√∫sica
                this.musicEnabled = true;
                
                // Estado del arrastre
                this.isDragging = false;
                this.draggingPiece = null;
                this.draggingPieceIndex = -1;
                this.dragStartX = 0;
                this.dragStartY = 0;
                this.currentDragX = 0;
                this.currentDragY = 0;
                this.activeTouchId = null;
                this.lastTap = 0;
                
                // Control de scroll en m√≥viles
                this.preventScroll = false;
                this.startY = 0;
                this.currentY = 0;
                
                this.init();
                this.setupEventListeners();
                this.setupResponsiveBehavior();
                this.preloadSounds();
            }

            preloadSounds() {
                const sounds = [
                    this.backgroundMusic,
                    this.lineCompleteSound,
                    this.piecePlaceSound,
                    this.gameOverSound,
                    this.rotateSound
                ];
                
                sounds.forEach(sound => {
                    sound.load();
                });
            }

            setupResponsiveBehavior() {
                this.resizeCanvases();
                window.addEventListener('resize', () => {
                    this.resizeCanvases();
                    this.draw();
                });
            }

            resizeCanvases() {
                const isMobile = window.innerWidth < 768;
                const isTablet = window.innerWidth >= 768 && window.innerWidth < 1024;
                const isDesktop = window.innerWidth >= 1024;
                
                // Tama√±os optimizados para cada dispositivo
                if (isMobile) {
                    this.cellSize = Math.min(window.innerWidth * 0.09, 40);
                } else if (isTablet) {
                    this.cellSize = Math.min(window.innerWidth * 0.07, 50);
                } else {
                    this.cellSize = Math.min(window.innerWidth * 0.06, 60);
                }
                
                // Canvas principal - m√°s grande en escritorio
                const mainBoardSize = this.boardSize * this.cellSize;
                this.mainCanvas.width = mainBoardSize;
                this.mainCanvas.height = mainBoardSize;
                this.mainCanvas.style.width = mainBoardSize + 'px';
                this.mainCanvas.style.height = mainBoardSize + 'px';
                
                // Canvas de piezas actuales
                const currentBoardWidth = isDesktop ? 400 : Math.min(800, window.innerWidth * 0.95);
                const currentBoardHeight = isMobile ? 120 : (isDesktop ? 200 : 150);
                this.currentCanvas.width = currentBoardWidth;
                this.currentCanvas.height = currentBoardHeight;
                this.currentCanvas.style.width = currentBoardWidth + 'px';
                this.currentCanvas.style.height = currentBoardHeight + 'px';
                
                // Canvas de pr√≥ximas piezas - horizontal
                const nextBoardWidth = isMobile ? Math.min(400, window.innerWidth * 0.9) : 300;
                const nextBoardHeight = isMobile ? 80 : (isDesktop ? 120 : 200);
                this.nextCanvas.width = nextBoardWidth;
                this.nextCanvas.height = nextBoardHeight;
                this.nextCanvas.style.width = nextBoardWidth + 'px';
                this.nextCanvas.style.height = nextBoardHeight + 'px';
                
                this.draw();
            }

            init() {
                this.board = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(0));
                this.currentPieces = [];
                this.nextPieces = [];
                this.generateInitialPieces();
                this.updateUI();
            }

            generateInitialPieces() {
                this.currentPieces = [];
                for (let i = 0; i < 3; i++) {
                    this.currentPieces.push(this.generateRandomPiece());
                }
                
                this.nextPieces = [];
                for (let i = 0; i < 3; i++) {
                    this.nextPieces.push(this.generateRandomPiece());
                }
            }

            generateRandomPiece() {
                const pieces = [
                    { shape: [[1,1],[1,1]], size: 2 },
                    { shape: [[1,0],[1,0],[1,1]], size: 3 },
                    { shape: [[0,1],[0,1],[1,1]], size: 3 },
                    { shape: [[1,1,1]], size: 3 },
                    { shape: [[1],[1],[1]], size: 3 },
                    { shape: [[1,1,1],[0,1,0]], size: 3 },
                    { shape: [[1,1,0],[0,1,1]], size: 3 },
                    { shape: [[0,1,1],[1,1,0]], size: 3 },
                    { shape: [[1]], size: 1 },
                    { shape: [[0,1,0],[1,1,1],[0,1,0]], size: 3 }
                ];
                
                const pieceTemplate = pieces[Math.floor(Math.random() * pieces.length)];
                return {
                    shape: JSON.parse(JSON.stringify(pieceTemplate.shape)),
                    color: this.getRandomColor(),
                    size: pieceTemplate.size,
                    id: Math.random().toString(36).substr(2, 9)
                };
            }

            getRandomColor() {
                const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            setupEventListeners() {
                this.currentCanvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.currentCanvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                document.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                document.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));
                
                this.currentCanvas.addEventListener('dragstart', (e) => e.preventDefault());
                this.currentCanvas.addEventListener('touchend', (e) => this.handleDoubleTap(e));
                
                // Prevenir scroll en iOS durante el arrastre
                document.addEventListener('touchmove', (e) => {
                    if (this.preventScroll && this.isDragging) {
                        e.preventDefault();
                    }
                }, { passive: false });
            }

            handleMouseDown(e) {
                if (this.gameState !== 'playing') return;
                const rect = this.currentCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                this.startDrag(x, y, e.clientX, e.clientY);
            }

            handleTouchStart(e) {
                if (this.gameState !== 'playing') return;
                if (this.activeTouchId !== null) return;
                
                const touch = e.touches[0];
                this.activeTouchId = touch.identifier;
                const rect = this.currentCanvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                // Guardar posici√≥n inicial para detectar scroll
                this.startY = touch.clientY;
                this.currentY = touch.clientY;
                this.preventScroll = false;
                
                this.startDrag(x, y, touch.clientX, touch.clientY);
                e.preventDefault();
            }

            startDrag(localX, localY, globalX, globalY) {
                const pieceIndex = this.findPieceAt(localX, localY);
                if (pieceIndex !== -1) {
                    this.isDragging = true;
                    this.draggingPiece = JSON.parse(JSON.stringify(this.currentPieces[pieceIndex]));
                    this.draggingPieceIndex = pieceIndex;
                    this.dragStartX = globalX;
                    this.dragStartY = globalY;
                    this.currentDragX = globalX;
                    this.currentDragY = globalY;
                    this.currentCanvas.classList.add('dragging');
                    this.draw();
                }
            }

            handleMouseMove(e) {
                if (!this.isDragging) return;
                this.currentDragX = e.clientX;
                this.currentDragY = e.clientY;
                this.draw();
            }

            handleTouchMove(e) {
                if (!this.isDragging) return;
                
                for (let touch of e.touches) {
                    if (touch.identifier === this.activeTouchId) {
                        // Detectar si el usuario est√° intentando desplazar o arrastrar
                        this.currentY = touch.clientY;
                        const deltaY = Math.abs(this.currentY - this.startY);
                        
                        // Si el movimiento es principalmente vertical, prevenir scroll
                        if (deltaY > 5) {
                            this.preventScroll = true;
                        }
                        
                        this.currentDragX = touch.clientX;
                        this.currentDragY = touch.clientY;
                        this.draw();
                        break;
                    }
                }
                
                // Prevenir scroll si estamos arrastrando
                if (this.preventScroll && this.isDragging) {
                    e.preventDefault();
                }
            }

            handleMouseUp(e) {
                if (!this.isDragging) return;
                const rect = this.mainCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                this.finishDrag(x, y);
            }

            handleTouchEnd(e) {
                if (!this.isDragging) return;
                const touch = e.changedTouches[0];
                const rect = this.mainCanvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                this.finishDrag(x, y);
                this.activeTouchId = null;
                this.preventScroll = false;
            }

            handleDoubleTap(e) {
                if (this.gameState !== 'playing') return;
                const currentTime = Date.now();
                if (currentTime - this.lastTap < 300) {
                    const touch = e.changedTouches[0];
                    const rect = this.currentCanvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const pieceIndex = this.findPieceAt(x, y);
                    if (pieceIndex !== -1) this.rotatePiece(pieceIndex);
                    e.preventDefault();
                }
                this.lastTap = currentTime;
            }

            finishDrag(x, y) {
                if (!this.isDragging || !this.draggingPiece) return;
                
                // Calcular la posici√≥n en la cuadr√≠cula
                const gridX = Math.floor(x / this.cellSize);
                const gridY = Math.floor(y / this.cellSize);
                
                // Ajustar la posici√≥n para que la pieza se coloque correctamente
                const adjustedGridX = Math.max(0, Math.min(gridX, this.boardSize - this.draggingPiece.shape[0].length));
                const adjustedGridY = Math.max(0, Math.min(gridY, this.boardSize - this.draggingPiece.shape.length));
                
                if (this.canPlacePiece(this.draggingPiece, adjustedGridX, adjustedGridY)) {
                    this.placePiece(this.draggingPiece, adjustedGridX, adjustedGridY);
                    this.playSound(this.piecePlaceSound);
                    this.currentPieces.splice(this.draggingPieceIndex, 1);
                    this.checkLines();
                    
                    if (this.currentPieces.length === 0) {
                        this.currentPieces = this.nextPieces;
                        this.nextPieces = [];
                        for (let i = 0; i < 3; i++) {
                            this.nextPieces.push(this.generateRandomPiece());
                        }
                    }
                    
                    this.score += 10;
                    
                    if (!this.hasValidMovesForAllPieces()) {
                        setTimeout(() => this.gameOver(), 1000);
                    }
                } else {
                    this.playSound(this.rotateSound);
                }
                
                this.resetDrag();
                this.draw();
                this.updateUI();
            }

            resetDrag() {
                this.isDragging = false;
                this.draggingPiece = null;
                this.draggingPieceIndex = -1;
                this.activeTouchId = null;
                this.currentCanvas.classList.remove('dragging');
            }

            findPieceAt(x, y) {
                const pieceWidth = this.currentCanvas.width / 3;
                const blockSize = Math.min(pieceWidth / 5, this.currentCanvas.height / 3);
                
                for (let i = 0; i < this.currentPieces.length; i++) {
                    const piece = this.currentPieces[i];
                    const pieceX = pieceWidth * i + pieceWidth / 2;
                    const pieceY = this.currentCanvas.height / 2;
                    const pieceDisplayWidth = piece.shape[0].length * blockSize;
                    const pieceDisplayHeight = piece.shape.length * blockSize;
                    
                    if (x >= pieceX - pieceDisplayWidth / 2 && x <= pieceX + pieceDisplayWidth / 2 &&
                        y >= pieceY - pieceDisplayHeight / 2 && y <= pieceY + pieceDisplayHeight / 2) {
                        return i;
                    }
                }
                return -1;
            }

            canPlacePiece(piece, gridX, gridY) {
                if (gridX < 0 || gridY < 0) return false;
                
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x] === 1) {
                            const boardX = gridX + x;
                            const boardY = gridY + y;
                            if (boardX >= this.boardSize || boardY >= this.boardSize || this.board[boardY][boardX] !== 0) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            placePiece(piece, gridX, gridY) {
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x] === 1) {
                            const boardX = gridX + x;
                            const boardY = gridY + y;
                            this.board[boardY][boardX] = { color: piece.color, pieceId: piece.id };
                            this.blocksPlaced++;
                        }
                    }
                }
            }

            checkLines() {
                let linesCleared = 0;
                let linesToClear = [];
                
                for (let y = 0; y < this.boardSize; y++) {
                    if (this.board[y].every(cell => cell !== 0)) {
                        linesToClear.push({ type: 'row', index: y });
                        linesCleared++;
                    }
                }
                
                for (let x = 0; x < this.boardSize; x++) {
                    let fullColumn = true;
                    for (let y = 0; y < this.boardSize; y++) {
                        if (this.board[y][x] === 0) {
                            fullColumn = false;
                            break;
                        }
                    }
                    if (fullColumn) linesToClear.push({ type: 'column', index: x });
                }
                
                linesToClear.forEach(line => {
                    if (line.type === 'row') this.clearLine(line.index);
                    else this.clearColumn(line.index);
                });
                
                if (linesCleared > 0) {
                    this.showMessage(this.getLineMessage(linesCleared));
                    this.playSound(this.lineCompleteSound);
                    const points = linesCleared * 100 * this.level;
                    this.score += points;
                    this.lines += linesCleared;
                    this.level = Math.floor(this.lines / 5) + 1;
                }
            }

            getLineMessage(linesCleared) {
                const messages = {
                    1: ["¬°L√çNEA COMPLETA!", "¬°BIEN HECHO!", "¬°PERFECTO!"],
                    2: ["¬°DOBLE L√çNEA!", "¬°INCRE√çBLE!", "¬°FANT√ÅSTICO!"],
                    3: ["¬°TRIPLE L√çNEA!", "¬°ASOMBROSO!", "¬°ESPECTACULAR!"],
                    4: ["¬°CU√ÅDRUPLE!", "¬°LEGENDARIO!", "¬°IMPRESIONANTE!"]
                };
                return (messages[linesCleared] || ["¬°EXCELENTE!"])[Math.floor(Math.random() * 3)];
            }

            showMessage(text) {
                const messageDisplay = document.getElementById('messageDisplay');
                messageDisplay.textContent = text;
                messageDisplay.style.display = 'block';
                setTimeout(() => messageDisplay.style.display = 'none', 1500);
            }

            clearLine(y) {
                for (let x = 0; x < this.boardSize; x++) this.board[y][x] = 0;
            }

            clearColumn(x) {
                for (let y = 0; y < this.boardSize; y++) this.board[y][x] = 0;
            }

            hasValidMovesForAllPieces() {
                for (let piece of this.currentPieces) {
                    if (this.hasValidMoveForPiece(piece)) return true;
                }
                return false;
            }

            hasValidMoveForPiece(piece) {
                const testPiece = JSON.parse(JSON.stringify(piece));
                for (let rotation = 0; rotation < 4; rotation++) {
                    for (let y = 0; y <= this.boardSize - testPiece.shape.length; y++) {
                        for (let x = 0; x <= this.boardSize - testPiece.shape[0].length; x++) {
                            if (this.canPlacePiece(testPiece, x, y)) return true;
                        }
                    }
                    if (rotation < 3) this.rotatePieceShape(testPiece);
                }
                return false;
            }

            rotatePiece(pieceIndex) {
                if (pieceIndex < this.currentPieces.length && this.gameState === 'playing') {
                    const piece = this.currentPieces[pieceIndex];
                    this.rotatePieceShape(piece);
                    this.playSound(this.rotateSound);
                    this.draw();
                }
            }

            rotatePieceShape(piece) {
                const rows = piece.shape.length;
                const cols = piece.shape[0].length;
                const newShape = [];
                for (let x = 0; x < cols; x++) {
                    newShape[x] = [];
                    for (let y = 0; y < rows; y++) {
                        newShape[x][y] = piece.shape[rows - 1 - y][x];
                    }
                }
                piece.shape = newShape;
            }

            playSound(audioElement) {
                if (this.musicEnabled) {
                    audioElement.currentTime = 0;
                    audioElement.play().catch(e => console.log("Audio play failed:", e));
                }
            }

            toggleMusic() {
                this.musicEnabled = !this.musicEnabled;
                const musicButton = document.querySelector('.music-control');
                if (this.musicEnabled) {
                    this.backgroundMusic.play().catch(e => console.log("Music play failed:", e));
                    musicButton.innerHTML = 'üéµ';
                } else {
                    this.backgroundMusic.pause();
                    musicButton.innerHTML = 'üîá';
                }
            }

            draw() {
                this.drawMainBoard();
                this.drawNextPieces();
                this.drawCurrentPieces();
                
                if (this.isDragging && this.draggingPiece) {
                    this.drawDraggingPiece();
                }
            }

            drawDraggingPiece() {
                const rect = this.mainCanvas.getBoundingClientRect();
                const x = this.currentDragX - rect.left;
                const y = this.currentDragY - rect.top;
                
                this.drawPiece(this.mainCtx, this.draggingPiece, x, y, this.cellSize, true);
                
                // Calcular la posici√≥n en la cuadr√≠cula
                const gridX = Math.floor(x / this.cellSize);
                const gridY = Math.floor(y / this.cellSize);
                
                // Ajustar la posici√≥n para que la pieza se muestre correctamente
                const adjustedGridX = Math.max(0, Math.min(gridX, this.boardSize - this.draggingPiece.shape[0].length));
                const adjustedGridY = Math.max(0, Math.min(gridY, this.boardSize - this.draggingPiece.shape.length));
                
                if (this.canPlacePiece(this.draggingPiece, adjustedGridX, adjustedGridY)) {
                    this.drawPiecePreview(this.mainCtx, this.draggingPiece, adjustedGridX, adjustedGridY, '#00FF00');
                } else {
                    this.drawPiecePreview(this.mainCtx, this.draggingPiece, adjustedGridX, adjustedGridY, '#FF0000');
                }
            }

            drawPiecePreview(ctx, piece, gridX, gridY, color) {
                ctx.save();
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.fillStyle = color + '20';
                
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x] === 1) {
                            const boardX = gridX + x;
                            const boardY = gridY + y;
                            
                            if (boardX < this.boardSize && boardY < this.boardSize) {
                                const cellX = boardX * this.cellSize;
                                const cellY = boardY * this.cellSize;
                                
                                ctx.fillRect(cellX + 2, cellY + 2, this.cellSize - 4, this.cellSize - 4);
                                ctx.strokeRect(cellX + 2, cellY + 2, this.cellSize - 4, this.cellSize - 4);
                            }
                        }
                    }
                }
                ctx.restore();
            }

            drawMainBoard() {
                this.mainCtx.clearRect(0, 0, this.mainCanvas.width, this.mainCanvas.height);
                this.mainCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.mainCtx.fillRect(0, 0, this.mainCanvas.width, this.mainCanvas.height);
                
                for (let y = 0; y < this.boardSize; y++) {
                    for (let x = 0; x < this.boardSize; x++) {
                        this.drawCell(this.mainCtx, x, y, this.board[y][x]);
                    }
                }
                
                this.mainCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.mainCtx.lineWidth = 1;
                for (let i = 0; i <= this.boardSize; i++) {
                    this.mainCtx.beginPath();
                    this.mainCtx.moveTo(i * this.cellSize, 0);
                    this.mainCtx.lineTo(i * this.cellSize, this.boardSize * this.cellSize);
                    this.mainCtx.stroke();
                    
                    this.mainCtx.beginPath();
                    this.mainCtx.moveTo(0, i * this.cellSize);
                    this.mainCtx.lineTo(this.boardSize * this.cellSize, i * this.cellSize);
                    this.mainCtx.stroke();
                }
            }

            drawCell(ctx, x, y, cell) {
                const cellX = x * this.cellSize;
                const cellY = y * this.cellSize;
                
                if (cell !== 0) {
                    ctx.fillStyle = cell.color;
                    ctx.fillRect(cellX + 1, cellY + 1, this.cellSize - 2, this.cellSize - 2);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(cellX + 1, cellY + 1, this.cellSize - 2, this.cellSize - 2);
                }
            }

            drawCurrentPieces() {
                this.currentCtx.clearRect(0, 0, this.currentCanvas.width, this.currentCanvas.height);
                this.currentCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                this.currentCtx.fillRect(0, 0, this.currentCanvas.width, this.currentCanvas.height);
                
                const pieceWidth = this.currentCanvas.width / 3;
                const blockSize = Math.min(pieceWidth / 5, this.currentCanvas.height / 3);
                
                for (let i = 0; i < this.currentPieces.length; i++) {
                    const piece = this.currentPieces[i];
                    const baseX = pieceWidth * i + pieceWidth / 2;
                    const baseY = this.currentCanvas.height / 2;
                    this.drawPiece(this.currentCtx, piece, baseX, baseY, blockSize, false);
                }
            }

            drawNextPieces() {
                this.nextCtx.clearRect(0, 0, this.nextCanvas.width, this.nextCanvas.height);
                this.nextCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                this.nextCtx.fillRect(0, 0, this.nextCanvas.width, this.nextCanvas.height);
                
                const isMobile = window.innerWidth < 768;
                const pieceWidth = this.nextCanvas.width / 3;
                const pieceHeight = this.nextCanvas.height;
                const blockSize = isMobile ? 
                    Math.min(pieceWidth / 4, pieceHeight / 3) : 
                    Math.min(pieceWidth / 5, pieceHeight / 3);
                
                for (let i = 0; i < this.nextPieces.length; i++) {
                    const piece = this.nextPieces[i];
                    const baseX = pieceWidth * i + pieceWidth / 2;
                    const baseY = pieceHeight / 2;
                    this.drawPiece(this.nextCtx, piece, baseX, baseY, blockSize, false);
                }
            }

            drawPiece(ctx, piece, baseX, baseY, blockSize, isDragging) {
                if (isDragging) ctx.globalAlpha = 0.8;
                
                const offsetX = - (piece.shape[0].length * blockSize) / 2;
                const offsetY = - (piece.shape.length * blockSize) / 2;
                
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x] === 1) {
                            const blockX = baseX + offsetX + x * blockSize;
                            const blockY = baseY + offsetY + y * blockSize;
                            
                            ctx.fillStyle = piece.color;
                            ctx.fillRect(blockX, blockY, blockSize - 2, blockSize - 2);
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(blockX, blockY, blockSize - 2, blockSize - 2);
                        }
                    }
                }
                
                if (isDragging) ctx.globalAlpha = 1.0;
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('lines').textContent = this.lines;
                document.getElementById('level').textContent = this.level;
                document.getElementById('blocksPlaced').textContent = this.blocksPlaced;
            }

            gameOver() {
                this.gameState = 'gameOver';
                this.playSound(this.gameOverSound);
                this.backgroundMusic.pause();
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalLines').textContent = this.lines;
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }

            start() {
                this.gameState = 'playing';
                document.getElementById('startScreen').classList.add('hidden');
                if (this.musicEnabled) this.backgroundMusic.play();
                this.draw();
            }

            reset() {
                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.blocksPlaced = 0;
                this.resetDrag();
                this.init();
                this.draw();
            }
        }

        // Funciones globales
        let blockGame;

        function startGame() {
            blockGame = new BlockPuzzleGame();
            blockGame.start();
        }

        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            startGame();
        }

        function rotatePiece(index) {
            if (blockGame) blockGame.rotatePiece(index);
        }

        function resetGame() {
            if (blockGame) {
                blockGame.reset();
                blockGame.start();
            }
        }

        function toggleMusic() {
            if (blockGame) blockGame.toggleMusic();
        }

        // Iniciar cuando se carga la p√°gina
        window.onload = function() {
            blockGame = new BlockPuzzleGame();
            document.getElementById('startScreen').classList.remove('hidden');
        };
    </script>
</body>
</html>