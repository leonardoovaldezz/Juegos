<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Arkanoid Deluxe ‚Äî Neon</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;500;700&display=swap" rel="stylesheet">
<style>
  /* -------------------------
     ESTILOS: Oscuro / Ne√≥n
     ------------------------- */
  :root{
    --bg1:#071226;
    --bg2:#07182a;
    --neon1:#66fcf1;
    --neon2:#9b7bff;
    --accent:#ffb86c;
    --panel: rgba(255,255,255,0.04);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:'Poppins',sans-serif;background:radial-gradient(circle at 10% 10%, #081228 0%, #071022 40%, #030416 100%);color:#fff;-webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
  .app{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px;}

  /* Contenedor responsivo: usa alto m√°ximo y se adapta bien a m√≥viles */
  .game-wrapper{
    width:100%;
    max-width:900px;
    height: min(92vh, 920px);
    border-radius:16px;
    overflow:hidden;
    position:relative;
    background: linear-gradient(180deg, rgba(4,8,20,0.45), rgba(2,4,12,0.7));
    box-shadow: 0 30px 80px rgba(2,6,23,0.75), inset 0 1px 0 rgba(255,255,255,0.02);
    border:1px solid rgba(255,255,255,0.03);
  }

  /* Canvas ocupa todo el wrapper; escalado manejado por JS */
  canvas{display:block;width:100%;height:100%;touch-action:none;background:linear-gradient(180deg, rgba(0,0,0,0.2), rgba(0,0,0,0.4));}

  /* HUD / botones */
  .hud{position:absolute;left:12px;right:12px;top:12px;display:flex;justify-content:space-between;pointer-events:none;gap:8px;}
  .hud .group{background: rgba(0,0,0,0.35);padding:8px 12px;border-radius:12px;display:flex;gap:10px;align-items:center;font-weight:600;font-size:0.95rem;pointer-events:auto;backdrop-filter: blur(4px);}
  .hud .center{justify-content:center;align-items:center}

  /* Overlay start */
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .panel{pointer-events:auto;background:linear-gradient(180deg, rgba(2,6,20,0.7), rgba(4,8,20,0.55));border-radius:14px;padding:20px;width:min(92%,460px);text-align:center;box-shadow:0 12px 30px rgba(0,0,0,0.6);border:1px solid var(--panel)}
  h1{margin:0 0 10px 0;font-size:1.9rem;background:linear-gradient(90deg,var(--neon1),var(--neon2));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
  p.lead{margin:8px 0 12px;color:rgba(255,255,255,0.9);line-height:1.4}
  .controls{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:8px}
  .btn{background:linear-gradient(90deg,var(--neon1),var(--neon2));border:none;padding:10px 14px;border-radius:10px;color:#021;cursor:pointer;font-weight:700;box-shadow:0 8px 20px rgba(109,84,255,0.12)}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:rgba(255,255,255,0.9);box-shadow:none}

  /* Popups */
  .popup{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:min(92%,420px);background:linear-gradient(180deg,rgba(0,0,0,0.88),rgba(0,0,0,0.72));border-radius:14px;padding:18px;display:none;pointer-events:auto;border:1px solid var(--panel)}
  .popup.show{display:block;animation:pop .18s ease-out}
  @keyframes pop{from{transform:translate(-50%,-50%) scale(.96);opacity:0}to{transform:translate(-50%,-50%) scale(1);opacity:1}}

  .power-ind{position:absolute;left:50%;transform:translateX(-50%);bottom:18px;padding:8px 12px;border-radius:16px;background:rgba(0,0,0,0.46);display:none;font-weight:700}

  /* Ayuda y botones t√°ctiles grandes para m√≥viles */
  .touch-hint{font-size:0.9rem;color:rgba(255,255,255,0.8);margin-top:8px}
  @media (max-width:520px){
    h1{font-size:1.4rem}
    .hud .group{font-size:0.86rem;padding:6px 10px}
    .btn{padding:10px 12px}
  }
</style>
</head>
<body>
<div class="app">
  <div class="game-wrapper" id="gameWrapper" role="application" aria-label="Arkanoid Deluxe">
    <canvas id="c" aria-hidden="false"></canvas>

    <!-- HUD -->
    <div class="hud" aria-hidden="false">
      <div class="group left" id="leftHud">
        <div id="score">Puntos: 0</div>
        <div id="lives" style="opacity:0.9">Vidas: 3</div>
      </div>
      <div class="group center"><div id="level">Nivel: 1</div></div>
      <div class="group right" style="justify-self:end">
        <button id="soundBtn" class="btn ghost" title="Silenciar/Activar sonido">üîä</button>
        <button id="helpBtn" class="btn ghost">?</button>
      </div>
    </div>

    <!-- indicador powerup -->
    <div class="power-ind" id="powerInd"></div>

    <!-- Start overlay -->
    <div class="overlay" id="startOverlay">
      <div class="panel" role="dialog" aria-label="Pantalla de inicio">
        <h1>üéÆ Arkanoid Deluxe</h1>
        <p class="lead">Mueve la paleta con ‚¨ÖÔ∏è ‚û°Ô∏è, tocando/arrastrando o con el mouse. Rebota la bola y destruye todos los bloques. ¬°Recoge power-ups!</p>
        <div class="controls">
          <button id="startBtn" class="btn">Comenzar</button>
          <button id="levelSelectBtn" class="btn ghost">Nivel 1</button>
        </div>
        <p class="touch-hint">M√∫sica synthwave generada en tiempo real ‚Ä¢ Sin archivos externos</p>
      </div>
    </div>

    <!-- Game over popup -->
    <div class="popup" id="gameOver">
      <h2 style="margin:6px 0 8px">üíÄ Fin del juego</h2>
      <p id="finalScore">Puntuaci√≥n final: 0</p>
      <div style="margin-top:12px" class="controls">
        <button id="restartBtn" class="btn">Jugar de nuevo</button>
        <button id="toMenuBtn" class="btn ghost">Men√∫</button>
      </div>
    </div>

    <!-- Level complete popup -->
    <div class="popup" id="levelComplete">
      <h2 style="margin:6px 0 8px">üéâ Nivel completado</h2>
      <p id="levelScore">Puntos del nivel: 0</p>
      <div style="margin-top:12px" class="controls">
        <button id="nextLevelBtn" class="btn">Siguiente nivel</button>
        <button id="menu2Btn" class="btn ghost">Men√∫</button>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================================================
   Arkanoid Deluxe ‚Äî Versi√≥n completa, responsiva y con audio
   - Tema: Oscuro / Ne√≥n (synthwave)
   - Nota: El canvas NO se redimensiona en cada frame (fix)
   ========================================================= */

/* ---------- Elementos DOM ---------- */
const wrapper = document.getElementById('gameWrapper');
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: true });

const startOverlay = document.getElementById('startOverlay');
const startBtn = document.getElementById('startBtn');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const levelEl = document.getElementById('level');
const powerInd = document.getElementById('powerInd');
const gameOverPopup = document.getElementById('gameOver');
const levelCompletePopup = document.getElementById('levelComplete');
const finalScoreEl = document.getElementById('finalScore');
const levelScoreEl = document.getElementById('levelScore');
const restartBtn = document.getElementById('restartBtn');
const nextLevelBtn = document.getElementById('nextLevelBtn');
const toMenuBtn = document.getElementById('toMenuBtn');
const menu2Btn = document.getElementById('menu2Btn');
const soundBtn = document.getElementById('soundBtn');
const helpBtn = document.getElementById('helpBtn');

let audioActive = true;
soundBtn.addEventListener('click', () => {
  audioActive = !audioActive;
  soundBtn.textContent = audioActive ? 'üîä' : 'üîà';
  if (audioActive) resumeAudio(); else suspendAudio();
});

/* ---------- Canvas scaling (only on resize / init) ---------- */
function resizeCanvasToDisplaySize(){
  const rect = wrapper.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const width = Math.max(320, Math.round(rect.width));
  const height = Math.max(420, Math.round(rect.height));
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';
  canvas.width = Math.floor(width * dpr);
  canvas.height = Math.floor(height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0); // map drawing to CSS pixels
}

/* ---------- Audio (synthwave pad + SFX) ---------- */
let audioCtx = null, masterGain = null, bgGain = null;
let bgOscs = [], bgLfo = null, bgScheduler = null;

function ensureAudio(){
  if (!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain(); masterGain.gain.value = 0.9;
    bgGain = audioCtx.createGain(); bgGain.gain.value = 0.06;
    masterGain.connect(audioCtx.destination); bgGain.connect(masterGain);
  }
}
function resumeAudio(){
  ensureAudio();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  if (!bgScheduler) startBackground();
}
function suspendAudio(){
  if (audioCtx) audioCtx.suspend();
}

/* Background synth pad (simple chordal progression) */
function startBackground(){
  if (!audioCtx) return;
  // stop existing if any
  if (bgScheduler) { clearInterval(bgScheduler); bgScheduler = null; }
  // create two slow oscillators and an LFO
  const oscA = audioCtx.createOscillator();
  const oscB = audioCtx.createOscillator();
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'lowpass'; filter.frequency.value = 900;
  oscA.type = 'sine'; oscB.type = 'sine';
  oscA.frequency.value = 110; oscB.frequency.value = 220;
  const gA = audioCtx.createGain(); gA.gain.value = 0.6;
  const gB = audioCtx.createGain(); gB.gain.value = 0.35;
  oscA.connect(gA); gA.connect(filter);
  oscB.connect(gB); gB.connect(filter);
  filter.connect(bgGain);

  // subtle LFO to modulate filter
  const lfo = audioCtx.createOscillator();
  lfo.frequency.value = 0.06;
  const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 260;
  lfo.connect(lfoGain); lfoGain.connect(filter.frequency);

  oscA.start(); oscB.start(); lfo.start();
  bgOscs = [oscA, oscB]; bgLfo = lfo;

  // chord progression tick
  let idx = 0;
  const chords = [0,3,5,7]; // semitone offsets
  const base = 110; // A2
  const semitone = Math.pow(2,1/12);
  bgScheduler = setInterval(()=>{
    if (!audioActive) return;
    const offset = chords[idx % chords.length];
    const f1 = base * Math.pow(semitone, offset);
    const f2 = f1 * 2;
    try {
      oscA.frequency.linearRampToValueAtTime(f1, audioCtx.currentTime + 0.5);
      oscB.frequency.linearRampToValueAtTime(f2, audioCtx.currentTime + 0.5);
    } catch(e){}
    idx++;
  }, 1600);
}

/* SFX helper */
function sfx(type){
  if (!audioCtx || !audioActive) return;
  const now = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  const f = audioCtx.createBiquadFilter();
  if (type === 'bounce'){
    o.type = 'square'; o.frequency.setValueAtTime(600, now);
    g.gain.setValueAtTime(0.001, now); g.gain.exponentialRampToValueAtTime(0.12, now + 0.004); g.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
    f.type = 'highpass'; f.frequency.value = 300;
  } else if (type === 'break'){
    o.type = 'sawtooth'; o.frequency.setValueAtTime(200, now); o.frequency.exponentialRampToValueAtTime(900, now + 0.14);
    g.gain.setValueAtTime(0.12, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.22);
    f.type = 'lowpass'; f.frequency.value = 1200;
  } else if (type === 'power'){
    o.type = 'triangle'; o.frequency.setValueAtTime(900, now);
    g.gain.setValueAtTime(0.08, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.28);
    f.type = 'lowpass'; f.frequency.value = 1800;
  } else if (type === 'gameover'){
    o.type = 'sine'; o.frequency.setValueAtTime(220, now); o.frequency.exponentialRampToValueAtTime(60, now + 0.8);
    g.gain.setValueAtTime(0.15, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.9);
    f.type = 'lowpass'; f.frequency.value = 800;
  }
  o.connect(f); f.connect(g); g.connect(masterGain);
  o.start(now); o.stop(now + 1.1);
}

/* ---------- Game state ---------- */
let score = 0, lives = 3, level = 1;
let particles = [], powerUps = [], activePowerUps = {};
let powerUpTimer = 0, bricks = [], balls = [], paddle = null, brickCfg = null;
let gameOver = false, levelComplete = false, running = false;

/* ---------- Initialize defaults based on canvas size ---------- */
function makeDefaults(){
  score = 0; lives = 3; level = 1; particles = []; powerUps = []; activePowerUps = {}; powerUpTimer = 0; bricks = []; gameOver = false; levelComplete = false;
  const W = canvas.width / (window.devicePixelRatio || 1);
  const H = canvas.height / (window.devicePixelRatio || 1);

  // paddle adaptativo
  const pWidth = Math.min(150, Math.max(64, Math.round(W * 0.18)));
  paddle = { w: pWidth, h: Math.max(10, Math.round(W * 0.02)), x: W/2 - pWidth/2, y: H - Math.max(46, Math.round(H*0.07)), dx: 0, speed: Math.max(5, Math.round(W/140)), color: '#66fcf1', originalWidth: pWidth };

  // bola inicial
  const ballSize = Math.max(6, Math.round(W/70));
  balls = [{ x: W/2, y: paddle.y - 12, size: ballSize, speed: Math.max(3.5, W/240), dx: 3 * (Math.random()>0.5?1:-1), dy: -3, color: '#ffb86c', originalSpeed: Math.max(3.5, W/240) }];

  // ladrillos adaptativos (usar ancho y dejar margen)
  brickCfg = {
    row: Math.min(7, Math.max(4, Math.round(W/70))),
    col: Math.min(10, Math.max(5, Math.round(W/60))),
    padding: 8,
    offsetTop: Math.max(42, Math.round(H*0.07)),
    offsetLeft: 16,
    colors: ['#ff6b6b','#ffd56b','#ffeaa7','#76e7b2','#6fb3ff']
  };
  // calcular brick width con margen
  const totalPaddingX = (brickCfg.col - 1) * brickCfg.padding + 2*brickCfg.offsetLeft;
  const wCalc = Math.floor((W - totalPaddingX) / brickCfg.col);
  brickCfg.w = Math.max(36, wCalc);
  brickCfg.h = Math.max(16, Math.round(brickCfg.w * 0.38));

  createBricks();
  updateHUD();
}

/* Create bricks array */
function createBricks(){
  bricks = [];
  for (let r=0; r<brickCfg.row; r++){
    bricks[r] = [];
    for (let c=0; c<brickCfg.col; c++){
      const x = c * (brickCfg.w + brickCfg.padding) + brickCfg.offsetLeft;
      const y = r * (brickCfg.h + brickCfg.padding) + brickCfg.offsetTop;
      const strength = r < 2 ? 1 : r < 4 ? 2 : 3;
      bricks[r][c] = { x, y, w: brickCfg.w, h: brickCfg.h, status: true, strength, originalStrength: strength };
    }
  }
}

/* ---------- Drawing helpers ---------- */
function drawRoundedRect(x,y,w,h,r, fillStyle, strokeStyle, lineWidth=0){
  ctx.beginPath();
  const radius = Math.min(r, w/2, h/2);
  ctx.moveTo(x + radius, y);
  ctx.arcTo(x + w, y, x + w, y + h, radius);
  ctx.arcTo(x + w, y + h, x, y + h, radius);
  ctx.arcTo(x, y + h, x, y, radius);
  ctx.arcTo(x, y, x + w, y, radius);
  ctx.closePath();
  if (fillStyle){ ctx.fillStyle = fillStyle; ctx.fill(); }
  if (strokeStyle && lineWidth>0){ ctx.strokeStyle = strokeStyle; ctx.lineWidth = lineWidth; ctx.stroke(); }
}

function shadeColor(col, percent){
  const num = parseInt(col.replace('#',''),16);
  const r = (num>>16) + percent;
  const g = ((num>>8)&0x00FF) + percent;
  const b = (num & 0x0000FF) + percent;
  return '#' + ( (1<<24) + (clamp(r,0,255)<<16) + (clamp(g,0,255)<<8) + clamp(b,0,255) ).toString(16).slice(1);
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, Math.round(v))); }

/* ---------- Particles ---------- */
function createParticles(x,y,count,color){
  for(let i=0;i<count;i++){
    particles.push({ x, y, dx:(Math.random()-0.5)*4, dy:(Math.random()-0.5)*4, size:Math.random()*3+1, life:Math.floor(Math.random()*30+20), color });
  }
}
function drawParticles(){
  for (let i = particles.length-1; i>=0; i--){
    const p = particles[i];
    ctx.globalAlpha = Math.max(0, p.life/40);
    ctx.fillStyle = p.color || '#fff';
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    p.x += p.dx; p.y += p.dy; p.dy += 0.06; p.life--;
    if (p.life <= 0) particles.splice(i,1);
  }
}

/* ---------- Power-ups ---------- */
function createPowerUp(x,y){
  const types = ['expand','points','speed','multiball','shield'];
  const type = types[Math.floor(Math.random()*types.length)];
  const size = Math.max(10, Math.round(canvas.width/(window.devicePixelRatio||1)/42));
  powerUps.push({ x, y, size, dy:2 + Math.random()*1.5, type, color:getPowerUpColor(type) });
}
function getPowerUpColor(type){
  return type === 'expand' ? '#4caf50' : type === 'points' ? '#ffc107' : type === 'speed' ? '#ff6b6b' : type === 'multiball' ? '#9c27b0' : '#34ace0';
}
function getPowerUpName(type){
  if(type==='expand') return 'Paleta Grande';
  if(type==='points') return 'Puntos Extra';
  if(type==='speed') return 'Velocidad+';
  if(type==='multiball') return 'Multipelota';
  if(type==='shield') return 'Escudo';
  return 'Power-up';
}
function drawPowerUps(){
  for (let i=powerUps.length-1;i>=0;i--){
    const p = powerUps[i];
    ctx.beginPath();
    ctx.arc(p.x + p.size/2, p.y, p.size, 0, Math.PI*2);
    ctx.fillStyle = p.color; ctx.fill(); ctx.closePath();
    ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(255,255,255,0.14)'; ctx.stroke();
    p.y += p.dy;
    // colisi√≥n con paleta
    if (p.x + p.size/2 > paddle.x && p.x + p.size/2 < paddle.x + paddle.w && p.y + p.size > paddle.y) {
      applyPowerUp(p.type); sfx('power'); powerUps.splice(i,1);
    } else if (p.y > canvas.height/(window.devicePixelRatio||1) + 50) powerUps.splice(i,1);
  }
}
function applyPowerUp(type){
  showPowerIndicator(type);
  switch(type){
    case 'expand':
      paddle.w = Math.min(paddle.w + 40, paddle.originalWidth * 2);
      activePowerUps.expand = 900; break;
    case 'points':
      score += 150; break;
    case 'speed':
      balls.forEach(b => { b.speed += 0.8; b.dx *= 1.05; b.dy *= 1.05; });
      activePowerUps.speed = 700; break;
    case 'multiball':
      const copy = balls.slice(0);
      for (let i=0;i<Math.min(3,copy.length);i++){
        const b0 = copy[i];
        const nb = { x:b0.x, y:b0.y, size:b0.size, speed:b0.speed, dx:(Math.random()-0.5)*6, dy:-Math.abs(b0.dy)-Math.random()*1.6, color:'#ffb86c', originalSpeed:b0.originalSpeed };
        balls.push(nb);
      }
      break;
    case 'shield':
      activePowerUps.shield = 700; break;
  }
}
function showPowerIndicator(type){
  powerInd.textContent = `¬°${getPowerUpName(type)}!`; powerInd.style.display = 'block';
  setTimeout(()=>{ powerInd.style.display = 'none'; }, 1600);
}

/* ---------- Physics & collisions ---------- */
function movePaddle(){
  paddle.x += paddle.dx;
  const W = canvas.width/(window.devicePixelRatio||1);
  if (paddle.x < 0) paddle.x = 0;
  if (paddle.x + paddle.w > W) paddle.x = W - paddle.w;
}

function moveBalls(){
  const W = canvas.width/(window.devicePixelRatio||1);
  const H = canvas.height/(window.devicePixelRatio||1);
  for (let i=balls.length-1;i>=0;i--){
    const b = balls[i];
    b.x += b.dx; b.y += b.dy;
    // walls
    if (b.x - b.size < 0) { b.x = b.size + 1; b.dx *= -1; sfx('bounce'); createParticles(b.x,b.y,3,'#fff'); }
    if (b.x + b.size > W) { b.x = W - b.size - 1; b.dx *= -1; sfx('bounce'); createParticles(b.x,b.y,3,'#fff'); }
    if (b.y - b.size < 0) { b.y = b.size + 1; b.dy *= -1; sfx('bounce'); createParticles(b.x,b.y,3,'#fff'); }
    // paddle
    if (b.x > paddle.x && b.x < paddle.x + paddle.w && b.y + b.size > paddle.y && b.y - b.size < paddle.y + paddle.h) {
      const hitPos = (b.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
      b.dx = hitPos * (5 + Math.abs(b.speed/1.2));
      b.dy = -Math.abs(b.dy) || -Math.abs(b.speed);
      b.y = paddle.y - b.size - 1;
      sfx('bounce'); createParticles(b.x,b.y,6,paddle.color);
    }
    // bottom
    if (b.y - b.size > H) {
      if (activePowerUps.shield) {
        b.y = H - 120; b.dy = -Math.abs(b.speed); delete activePowerUps.shield;
      } else {
        balls.splice(i,1);
        if (balls.length === 0) {
          lives--; sfx('gameover');
          if (lives <= 0) { gameOver = true; showGameOver(); }
          else { resetBall(); }
        }
      }
    }
  }
}

function collisionDetection(){
  for (let bi=0; bi<balls.length; bi++){
    const ball = balls[bi];
    for (let r=0; r<bricks.length; r++){
      for (let c=0; c<bricks[r].length; c++){
        const b = bricks[r][c];
        if (!b || !b.status) continue;
        if (ball.x > b.x && ball.x < b.x + b.w && ball.y > b.y && ball.y < b.y + b.h){
          const prevX = ball.x - ball.dx;
          if (prevX < b.x || prevX > b.x + b.w) ball.dx *= -1; else ball.dy *= -1;
          b.strength--;
          if (b.strength <= 0){
            b.status = false; score += 10 * b.originalStrength;
            createParticles(b.x + b.w/2, b.y + b.h/2, 14, brickCfg.colors[r % brickCfg.colors.length]);
            if (Math.random() < 0.16) createPowerUp(b.x, b.y + b.h/2);
            sfx('break');
          } else {
            createParticles(b.x + b.w/2, b.y + b.h/2, 6, '#fff'); sfx('bounce');
          }
          checkLevelComplete();
        }
      }
    }
  }
}

function checkLevelComplete(){
  let left = 0;
  for (let r=0;r<bricks.length;r++) for (let c=0;c<bricks[r].length;c++) if (bricks[r][c] && bricks[r][c].status) left++;
  if (left === 0){ levelComplete = true; showLevelComplete(); }
}

/* ---------- Reset ball ---------- */
function resetBall(){
  const W = canvas.width/(window.devicePixelRatio||1);
  balls = [{ x: W/2, y: paddle.y - 12, size: Math.max(6, Math.round(W/70)), speed: Math.max(3.5, W/240), dx: 3 * (Math.random()>0.5?1:-1), dy: -3, color:'#ffb86c', originalSpeed: Math.max(3.5, W/240) }];
  paddle.w = paddle.originalWidth;
}

/* ---------- Update powerups ---------- */
function updatePowerUps(){
  powerUpTimer++;
  for (const t in activePowerUps){
    activePowerUps[t]--;
    if (activePowerUps[t] <= 0){ removePowerUp(t); delete activePowerUps[t]; }
  }
}
function removePowerUp(type){
  if (type === 'expand') paddle.w = paddle.originalWidth;
  if (type === 'speed') balls.forEach(b => { b.speed = b.originalSpeed; });
}

/* ---------- Drawing main ---------- */
function draw(){
  // NOTA: NO llamar resizeCanvasToDisplaySize() aqu√≠ (fix responsivity)
  const W = canvas.width / (window.devicePixelRatio || 1);
  const H = canvas.height / (window.devicePixelRatio || 1);

  // fondo sutil + glow lines
  ctx.clearRect(0,0,W,H);
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'rgba(6,13,29,0.2)'); g.addColorStop(1,'rgba(3,6,18,0.25)');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  // estrellas / grid neon
  for (let i=0;i<40;i++){
    const sx = (i*47 + Math.floor(powerUpTimer/3)) % W;
    const sy = (i*31 + (i*7)) % (H*0.5);
    const s = (Math.sin((i+powerUpTimer)*0.025) + 1.2) * 0.5;
    ctx.fillStyle = `rgba(255,255,255,${0.02 * s})`; ctx.fillRect(sx, sy, 1, 1);
  }

  // draw bricks
  for (let r=0;r<bricks.length;r++){
    for (let c=0;c<bricks[r].length;c++){
      const b = bricks[r][c];
      if (!b || !b.status) continue;
      let color = b.strength === 3 ? '#ff3b30' : b.strength === 2 ? '#ffb74d' : brickCfg.colors[r % brickCfg.colors.length];
      const bg = ctx.createLinearGradient(b.x, b.y, b.x + b.w, b.y + b.h);
      bg.addColorStop(0, shadeColor(color, -8));
      bg.addColorStop(1, shadeColor(color, 8));
      drawRoundedRect(b.x, b.y, b.w, b.h, 6, bg, 'rgba(255,255,255,0.06)', 1);
      // little highlight
      ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(b.x + 6, b.y + 4, 10, 4);
    }
  }

  // particles & powerups
  drawParticles();
  drawPowerUps();

  // paddle shield
  if (activePowerUps.shield){
    drawRoundedRect(paddle.x - 8, paddle.y - 8, paddle.w + 16, paddle.h + 16, 14, 'rgba(52,172,224,0.06)');
  }
  // paddle
  drawRoundedRect(paddle.x, paddle.y, paddle.w, paddle.h, 8, paddle.color);

  // balls
  balls.forEach(b => {
    if (activePowerUps.speed){
      ctx.beginPath(); ctx.arc(b.x + Math.sin(powerUpTimer*0.12*b.size)*1.2, b.y, b.size + 3, 0, Math.PI*2); ctx.fillStyle = 'rgba(255,107,107,0.14)'; ctx.fill();
    }
    ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI*2); ctx.fillStyle = b.color; ctx.fill(); ctx.closePath();
  });

  // subtle HUD neon glow (draw over canvas)
  // (HUD textual elements are DOM; this is only optional glow)
}

/* ---------- Update / Loop ---------- */
function update(){
  if (gameOver || levelComplete || !running) return;
  movePaddle(); moveBalls(); collisionDetection(); updatePowerUps();
  updateHUD();
}
function loop(){
  update(); draw(); requestAnimationFrame(loop);
}

/* ---------- HUD ---------- */
function updateHUD(){
  scoreEl.textContent = `Puntos: ${score}`;
  livesEl.textContent = `Vidas: ${lives}`;
  levelEl.textContent = `Nivel: ${level}`;
}

/* ---------- UI functions ---------- */
function showGameOver(){
  finalScoreEl.textContent = `Puntuaci√≥n final: ${score}`;
  gameOverPopup.classList.add('show'); sfx('gameover');
}
function hideGameOver(){ gameOverPopup.classList.remove('show'); }
function showLevelComplete(){ levelScoreEl.textContent = `Puntos del nivel: ${score}`; levelCompletePopup.classList.add('show'); }
function hideLevelComplete(){ levelCompletePopup.classList.remove('show'); }

/* ---------- Controls ---------- */
document.addEventListener('keydown', e => {
  if (!paddle) return;
  if (e.key === 'ArrowLeft') paddle.dx = -paddle.speed;
  if (e.key === 'ArrowRight') paddle.dx = paddle.speed;
});
document.addEventListener('keyup', e => {
  if (!paddle) return;
  if (['ArrowLeft','ArrowRight'].includes(e.key)) paddle.dx = 0;
});

/* Touch / mouse controls: improved for mobile */
let dragging = false;
canvas.addEventListener('touchstart', e => {
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = (touch.clientX - rect.left);
  if (paddle) { paddle.x = x - paddle.w/2; }
  dragging = true;
}, { passive:false });
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const touch = e.touches[0]; const rect = canvas.getBoundingClientRect(); const x = (touch.clientX - rect.left);
  if (paddle) paddle.x = x - paddle.w/2;
}, { passive:false });
canvas.addEventListener('touchend', e => { dragging = false; });

canvas.addEventListener('mousedown', e => {
  dragging = true; const rect = canvas.getBoundingClientRect(); if (paddle) paddle.x = e.clientX - rect.left - paddle.w/2;
});
window.addEventListener('mousemove', e => {
  if (!dragging) return; const rect = canvas.getBoundingClientRect(); if (paddle) paddle.x = e.clientX - rect.left - paddle.w/2;
});
window.addEventListener('mouseup', () => dragging = false);

/* ---------- Buttons ---------- */
startBtn.addEventListener('click', () => {
  startOverlay.style.display = 'none'; startGame(); resumeAudio();
});
restartBtn.addEventListener('click', () => {
  hideGameOver(); makeDefaults(); resetBall(); running = true; if (audioActive) resumeAudio();
});
toMenuBtn.addEventListener('click', () => { hideGameOver(); startOverlay.style.display = ''; running = false; });
nextLevelBtn.addEventListener('click', () => {
  level++; hideLevelComplete();
  brickCfg.row = Math.min(8, brickCfg.row + 1); createBricks();
  balls.forEach(b => { b.speed += 0.4; b.originalSpeed += 0.4; });
  resetBall(); running = true;
});
menu2Btn.addEventListener('click', () => { hideLevelComplete(); startOverlay.style.display = ''; running = false; });

helpBtn.addEventListener('click', () => {
  alert('Controles:\n‚Ä¢ Flechas ‚Üê ‚Üí o tocar/arrastrar para mover la paleta.\n‚Ä¢ Recoge power-ups para mejorar.\n‚Ä¢ Presiona üîä para silenciar/activar sonido.');
});

/* ---------- Init / start ---------- */
function startGame(){
  running = true;
  resizeCanvasToDisplaySize();
  makeDefaults();
  updateHUD();
  if (audioActive) startBackground();
  requestAnimationFrame(loop);
}

/* Ensure audio permission on first interaction */
function initOnce(){
  document.addEventListener('click', function one(){ ensureAudio(); document.removeEventListener('click', one); }, { once:true });
}
initOnce();

/* ---------- Resize handler (only here we reflow and recalc sizes) ---------- */
let resizeTimeout = null;
window.addEventListener('resize', ()=> {
  // debounce
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(()=> {
    const wasRunning = running;
    running = false; // pause updates while recalculating
    resizeCanvasToDisplaySize();
    makeDefaults();
    if (wasRunning) running = true;
  }, 120);
});

/* Start with overlay visible */
startOverlay.style.display = '';

/* If page loaded and user wants immediate resize */
window.addEventListener('load', () => { resizeCanvasToDisplaySize(); });

</script>
</body>
</html>